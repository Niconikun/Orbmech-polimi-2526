function dkep_dt = gauss_planetary_equations(~, kep, mu, a_per_func)
% GAUSS_PLANETARY_EQUATIONS Computes derivatives of Keplerian elements using Gauss equations
%
% INPUT:
%   t          - Time (can be omitted for autonomous systems)
%   kep        - Keplerian elements [6x1]: [a; e; i; Omega; omega; theta] (angles in radians)
%   mu         - Gravitational parameter [km^3/s^2]
%   a_per_func - Function handle: a_per = a_per_func(t, kep) 
%                Returns perturbing acceleration in RSW frame [3x1] (km/s^2)
%
% OUTPUT:
%   dkep_dt    - Derivatives of Keplerian elements [6x1]
%
% REFERENCES:
%   Montenbruck & Gill (2000), "Satellite Orbits"
%   Vallado (2013), "Fundamentals of Astrodynamics and Applications"

    % Extract Keplerian elements
    a = kep(1);         % Semi-major axis [km]
    e = kep(2);         % Eccentricity
    i = kep(3);         % Inclination [rad]
    %Omega = kep(4);     % RAAN [rad]
    omega = kep(5);     % Argument of perigee [rad]
    theta = kep(6);     % True anomaly [rad]
    
    % Get perturbing accelerations in RSW frame
    % Note: We need to pass the current time if needed by a_per_func
    % The ~ in function input means we ignore time if not needed
    a_per = a_per_func(0, kep);  % Assuming autonomous or you can pass actual time
    
    a_R = a_per(1);  % Radial component
    a_T = a_per(2);  % Transversal component
    a_N = a_per(3);  % Normal (out-of-plane) component
    
    % Useful intermediate quantities
    p = a * (1 - e^2);        % Semi-latus rectum [km]
    h = sqrt(mu * p);         % Angular momentum [km^2/s]
    r = p / (1 + e * cos(theta));  % Radial distance [km]
    
    % Argument of latitude
    u = omega + theta;
    
    % Gauss Planetary Equations
    da_dt = (2 * a^2 / h) * (e * sin(theta) * a_R + (p / r) * a_T); %good
    
    de_dt = (1 / h) * (p * sin(theta) * a_R + ...
                      ((p + r) * cos(theta) + r * e) * a_T); % good
    
    di_dt = (r * cos(u) / h) * a_N; %good
    
    dOmega_dt = (r * sin(u) / (h * sin(i))) * a_N; 
    
    domega_dt = (1 / (h * e)) * (-p * cos(theta) * a_R + ...
                                (p + r) * sin(theta) * a_T) - ...
                (r * sin(u) * cos(i) / (h * sin(i))) * a_N;
    
    dtheta_dt = (h / r^2) + ...
                (1 / (e * h)) * (p * cos(theta) * a_R - ...
                                (p + r) * sin(theta) * a_T);
    
    % Handle special case for circular orbits (e ≈ 0)
    if e < 1e-10
        % For near-circular orbits, we can use different formulations
        % or switch to mean anomaly. Here we'll use a small value
        eps_e = 1e-10;
        de_dt = (1 / h) * (p * sin(theta) * a_R + ...
                          ((p + r) * cos(theta) + r * eps_e) * a_T);
        
        domega_dt = (1 / (h * eps_e)) * (-p * cos(theta) * a_R + ...
                                        (p + r) * sin(theta) * a_T) - ...
                    (r * sin(u) * cos(i) / (h * sin(i))) * a_N;
    end
    
    % For equatorial orbits (i ≈ 0), handle singularities
    if sin(i) < 1e-10
        % Use alternative formulation for equatorial orbits
        % Combine Omega and omega into longitude of periapsis
        % Here we'll use a small value to avoid division by zero
        sin_i = 1e-10;
        dOmega_dt = (r * sin(u) / (h * sin_i)) * a_N;
        domega_dt = domega_dt + (r * sin(u) * cos(i) / (h * sin_i)) * a_N;
    end
    
    % Output derivatives
    dkep_dt = [da_dt; de_dt; di_dt; dOmega_dt; domega_dt; dtheta_dt];
end